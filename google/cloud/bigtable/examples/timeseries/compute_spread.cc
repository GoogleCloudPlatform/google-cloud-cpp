// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "taq.pb.h"
#include "google/cloud/bigtable/data_client.h"
#include "google/cloud/bigtable/table.h"
#include <future>
#include <numeric>
#include <sstream>

/**
 * @file
 *
 * This example shows how to perform a parallel computation on many timeseries
 * stored in Cloud Bigtable.
 *
 * The input for this example is the table generated by `shuffle_taq_nbbo.cc`.
 * The row keys in this table are in `SYMBOL#YYYYMMDD` format, and the
 * "shuffled:taq" column contains all the quotes for a day.
 * `parsed` column family contains a `nbbo` column, the values of these column
 * are serialized `taq.Quote` protos.
 *
 * This example reads the data from this table and produces a new table with a
 * single row for each symbol, and all the quotes in a single column with a
 * serialized `taq.QuoteSequence` proto.
 */

namespace {
using SpreadResult = std::vector<std::pair<std::string, float>>;
namespace cbt = google::cloud::bigtable;

/// Compute the top-K symbols by average spread in the range [@p begin, @p end).
SpreadResult TopKBySpread(cbt::Table& table, int K, std::string const& yyyymmdd,
                          std::string begin, std::string end);

/// Just get the top K from a larger set of results.
SpreadResult FilterTopK(SpreadResult result, int K);
}  // anonymous namespace

int main(int argc, char* argv[]) try {
  // Make sure we have the right number of arguments.
  if (argc != 4) {
    std::string const cmd = argv[0];
    auto last_slash = std::string(argv[0]).find_last_of('/');
    std::cerr << "Usage: " << cmd.substr(last_slash + 1)
              << " <project> <instance> <yyyymmdd>" << std::endl;
    return 1;
  }
  std::string const project_id = argv[1];
  std::string const instance_id = argv[2];
  std::string const yyyymmdd = argv[3];

  cbt::ClientOptions options;
  options.SetLoadBalancingPolicyName("round_robin");
  constexpr long MiB = 1024 * 1024;
  options.SetMaxReceiveMessageSize(16 * MiB);
  cbt::Table input(
      cbt::CreateDefaultDataClient(project_id, instance_id, options),
      "shuffled-data");

  constexpr int K = 10;
  auto work = [&input, &yyyymmdd](std::string begin, std::string end, int K) {
    return TopKBySpread(input, K, yyyymmdd, std::move(begin), std::move(end));
  };

  std::cout << "Executing parallel top-k by spread " << std::flush;
  auto start = std::chrono::steady_clock::now();
  std::vector<std::future<SpreadResult>> tasks;
  // Reasonably good splits picked using estimate_split_points.cc.  The empty
  // strings at the beginning and end mean "infinity" for Cloud Bigtable key
  // ranges.
  std::vector<std::string> splits{
      "",   "AI", "AT", "BI", "CB", "CN", "CX", "DM", "EE", "EW", "FN",
      "GG", "HD", "IE", "IW", "JP", "LN", "ML", "NB", "OE", "PG", "QL",
      "RR", "SI", "SP", "T",  "TR", "UG", "UW", "VT", "WW", "XO", ""};
  for (std::size_t i = 0; i != splits.size() - 1; ++i) {
    tasks.emplace_back(
        std::async(std::launch::async, work, splits[i], splits[i + 1], K));
  }

  int task = 0;
  SpreadResult combined;
  for (auto& t : tasks) {
    try {
      auto result = t.get();
      combined.insert(combined.end(), result.begin(), result.end());
    } catch (std::exception const& ex) {
      std::cerr << "Exception raised by task [" << task << "]: " << ex.what()
                << std::endl;
    }
    ++task;
  }
  auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(
      std::chrono::steady_clock::now() - start);
  std::cout << " DONE in " << elapsed.count() << "s" << std::endl;

  combined = FilterTopK(std::move(combined), K);

  for (auto const& r : combined) {
    std::cout << r.first << " " << r.second << std::endl;
  }

  return 0;
} catch (std::exception const& ex) {
  std::cerr << "Standard exception raised: " << ex.what() << std::endl;
  return 1;
}

namespace {
SpreadResult TopKBySpread(cbt::Table& table, int K, std::string const& yyyymmdd,
                          std::string begin, std::string end) {
  SpreadResult result;
  using F = cbt::Filter;
  auto reader = table.ReadRows(
      cbt::RowSet(cbt::RowRange::Range(std::move(begin), std::move(end))),
      F::Chain(F::RowKeysRegex(".*#" + yyyymmdd),
               F::ColumnRangeClosed("taq", "quotes", "quotes")));
  taq::QuoteSequence current_quotes;
  for (auto const& row : reader) {
    std::istringstream tokens(row.row_key());
    tokens.exceptions(std::ios::failbit);

    std::string symbol;
    std::getline(tokens, symbol, '#');
    for (auto const& cell : row.cells()) {
      taq::QuoteSequence quotes;
      quotes.ParseFromString(cell.value());
      if (quotes.bid_price_size() != quotes.offer_price_size()) {
        std::ostringstream os;
        os << "Incorrect format for quotes in " << row.row_key() << std::endl;
        throw std::runtime_error(os.str());
      }
      double bid = std::accumulate(quotes.bid_price().begin(),
                                   quotes.bid_price().end(), 0.0);
      double offer = std::accumulate(quotes.offer_price().begin(),
                                     quotes.offer_price().end(), 0.0);
      result.emplace_back(symbol, (offer - bid) / quotes.bid_price_size());
    }
  }
  return FilterTopK(std::move(result), K);
}

SpreadResult FilterTopK(SpreadResult result, int K) {
  std::sort(result.begin(), result.end(),
            [](SpreadResult::value_type const& lhs,
               SpreadResult::value_type const& rhs) {
              return lhs.second > rhs.second;
            });
  result.resize(std::min(static_cast<std::size_t>(K), result.size()));
  return result;
}

}  // namespace
