// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef GOOGLE_CLOUD_CPP_GOOGLE_CLOUD_INTERNAL_SOURCE_ACCUMULATORS_H
#define GOOGLE_CLOUD_CPP_GOOGLE_CLOUD_INTERNAL_SOURCE_ACCUMULATORS_H

#include "google/cloud/future.h"
#include "google/cloud/version.h"
#include "absl/meta/type_traits.h"
#include "absl/types/variant.h"
#include <vector>

namespace google {
namespace cloud {
inline namespace GOOGLE_CLOUD_CPP_NS {
namespace internal {

template <typename Source>
using AccumulateAllEventsType =
    absl::variant<std::vector<typename Source::value_type>,
                  typename Source::error_type>;

/**
 * Accumulate all the values generated by @p source into a vector.
 *
 * This is mostly used for testing, it uses the background threads to accumulate
 * values, returning a `future<>` which is satisfied when the source is closed.
 *
 * The returned future is of type `future<variant<vector<T>, E>>` where `T` and
 * `E` are the value type and error type in the original source. The returned
 * future is satisfied with an error if the original source is closed with an
 * error.
 *
 * @tparam Source
 * @param source
 * @return
 */
template <typename Source>
future<AccumulateAllEventsType<absl::decay_t<Source>>> AccumulateAllEvents(
    Source&& source) {
  using source_t = absl::decay_t<Source>;
  using value_t = typename source_t::value_type;
  using error_t = typename source_t::error_type;
  using event_t = AccumulateAllEventsType<source_t>;
  using source_event_t = absl::variant<value_t, error_t>;

  /**
   * Accumulates the values generated by @p source
   */
  struct Accumulator {
    source_t source;
    std::vector<value_t> results;

    void Start(promise<event_t> done) {
      /// Simulate extended lambda captures, we want to move @p done.
      struct OnNext {
        Accumulator* self;
        promise<event_t> done;
        void operator()(future<source_event_t> f) {
          self->OnNext(f.get(), std::move(done));
        }
      };
      source.next().then(OnNext{this, std::move(done)});
    }

    void OnNext(source_event_t v, promise<event_t> done) {
      struct Visitor {
        Accumulator* self;
        promise<event_t> done;

        void operator()(value_t v) {
          self->results.push_back(v);
          self->Start(std::move(done));
        }
        void operator()(error_t s) {
          if (s.ok()) {
            done.set_value(std::move(self->results));
          } else {
            done.set_value(std::move(s));
          }
        }
      };
      absl::visit(Visitor{this, std::move(done)}, v);
    }
  };

  // Use `shared_ptr<>` because C++11
  auto accumulator = std::make_shared<Accumulator>(
      Accumulator{std::forward<Source>(source), {}});
  promise<event_t> done;
  auto f = done.get_future();
  accumulator->Start(std::move(done));
  // This is an idiom to extend the lifetime of `accumulator` until the
  // (returned) future is satisfied.  The (returned) future owns the lambda,
  // which owns `accumulator`. When the returned future is satisfied the lambda
  // is called, then deleted, and that deletes `accumulator`.
  return f.then([accumulator](future<event_t> f) { return f.get(); });
}

}  // namespace internal
}  // namespace GOOGLE_CLOUD_CPP_NS
}  // namespace cloud
}  // namespace google

#endif  // GOOGLE_CLOUD_CPP_GOOGLE_CLOUD_INTERNAL_SOURCE_ACCUMULATORS_H
